name: CD - Build and Push Images

on:
  workflow_run:
    workflows: ["CI"]
    types: [completed]
  workflow_dispatch:

env:
  AWS_REGION: us-east-1

jobs:
  check-ci-status:
    name: Check CI Status
    runs-on: ubuntu-latest
    outputs:
      should_deploy: ${{ steps.verify.outputs.should_deploy }}
      branch: ${{ steps.verify.outputs.branch }}
    steps:
      - name: Verify trigger and CI status
        id: verify
        run: |
          echo "‚úÖ Checking deployment conditions"
          echo "Event: ${{ github.event_name }}"
          echo "Ref: ${{ github.ref }}"
          echo "Branch: ${{ github.ref_name }}"
          
          SHOULD_DEPLOY="false"
          BRANCH="${{ github.ref_name }}"
          
          # Check if triggered by workflow_run (after CI)
          if [ "${{ github.event_name }}" == "workflow_run" ]; then
            echo "CI Workflow: ${{ github.event.workflow_run.name }}"
            echo "CI Conclusion: ${{ github.event.workflow_run.conclusion }}"
            echo "CI Branch: ${{ github.event.workflow_run.head_branch }}"
            
            # Only deploy if CI succeeded and branch is main, develop, or flux-test
            if [ "${{ github.event.workflow_run.conclusion }}" == "success" ] && \
               ([ "${{ github.event.workflow_run.head_branch }}" == "main" ] || \
                [ "${{ github.event.workflow_run.head_branch }}" == "develop" ] || \
                [ "${{ github.event.workflow_run.head_branch }}" == "flux-test" ]); then
              SHOULD_DEPLOY="true"
              BRANCH="${{ github.event.workflow_run.head_branch }}"
              echo "‚úÖ CI succeeded on $BRANCH, proceeding with deployment"
            else
              echo "‚ùå CI did not succeed or branch is not main/develop, skipping deployment"
            fi
          
          # Check if triggered by workflow_dispatch (manual)
          elif [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            SHOULD_DEPLOY="true"
            BRANCH="${{ github.ref_name }}"
            echo "‚úÖ Manual trigger, proceeding with deployment"
          else
            echo "‚ùå Unknown trigger: ${{ github.event_name }}, skipping deployment"
          fi
          
          # Always set outputs (even if skipping)
          echo "should_deploy=$SHOULD_DEPLOY" >> $GITHUB_OUTPUT
          echo "branch=$BRANCH" >> $GITHUB_OUTPUT
          echo "Deployment decision: $SHOULD_DEPLOY for branch: $BRANCH"
          
          # Exit successfully (job will complete, but dependent jobs check the output)
          if [ "$SHOULD_DEPLOY" != "true" ]; then
            echo "‚è≠Ô∏è  Skipping deployment - dependent jobs will be skipped"
          fi

  build-backend:
    name: Build Backend
    needs: [check-ci-status]
    if: needs.check-ci-status.outputs.should_deploy == 'true'
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    outputs:
      image: ${{ steps.image-info.outputs.image }}
      image_tag: ${{ steps.image-info.outputs.image_tag }}
    steps:
      - uses: actions/checkout@v4
        with:
          # Checkout the correct ref based on trigger type
          ref: ${{ github.event_name == 'workflow_run' && github.event.workflow_run.head_sha || github.ref }}
      
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
      
      - uses: aws-actions/amazon-ecr-login@v2
      
      - uses: docker/setup-buildx-action@v3
      
      - name: Get ECR registry
        id: ecr-registry
        run: |
          ECR_REGISTRY=$(aws sts get-caller-identity --query Account --output text)
          echo "registry_id=$ECR_REGISTRY" >> $GITHUB_OUTPUT
      
      - name: Build and push
        id: meta-backend
        uses: docker/metadata-action@v5
        with:
          images: ${{ steps.ecr-registry.outputs.registry_id }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ secrets.ECR_BACKEND_REPO }}
          tags: |
            type=sha
            type=raw,value=latest,enable={{is_default_branch}}
            type=ref,event=branch
      
      - uses: docker/build-push-action@v5
        with:
          context: ./backend
          push: true
          tags: ${{ steps.meta-backend.outputs.tags }}
          labels: |
            org.opencontainers.image.source=${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
      
      - name: Set image output
        id: image-info
        run: |
          # Get all tags from metadata action
          ALL_TAGS="${{ steps.meta-backend.outputs.tags }}"
          
          # Prefer SHA tag (unique per commit), fallback to first tag
          IMAGE_TAG=$(echo "$ALL_TAGS" | grep -E "sha-[a-f0-9]+" | head -n1 | sed 's/.*://' || echo "")
          
          if [ -z "$IMAGE_TAG" ]; then
            # Fallback: use first tag or commit SHA
            IMAGE_TAG=$(echo "$ALL_TAGS" | head -n1 | sed 's/.*://' || echo "")
          fi
          
          if [ -z "$IMAGE_TAG" ]; then
            # Last resort: use commit SHA directly
            IMAGE_TAG="${{ github.sha }}"
          fi
          
          # Construct full image path
          ECR_REGISTRY=$(aws sts get-caller-identity --query Account --output text)
          IMAGE="${ECR_REGISTRY}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ secrets.ECR_BACKEND_REPO }}:${IMAGE_TAG}"
          
          echo "image=$IMAGE" >> $GITHUB_OUTPUT
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "‚úÖ Backend image: $IMAGE (tag: $IMAGE_TAG)"
          echo "   All available tags: $ALL_TAGS"

  build-frontend:
    name: Build Frontend
    needs: [check-ci-status]
    if: needs.check-ci-status.outputs.should_deploy == 'true'
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    outputs:
      image: ${{ steps.image-info.outputs.image }}
      image_tag: ${{ steps.image-info.outputs.image_tag }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event_name == 'workflow_run' && github.event.workflow_run.head_sha || github.ref }}
      
      - uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
      
      - uses: aws-actions/amazon-ecr-login@v2
      
      - uses: docker/setup-buildx-action@v3
      
      - name: Get ECR registry
        id: ecr-registry
        run: |
          ECR_REGISTRY=$(aws sts get-caller-identity --query Account --output text)
          echo "registry_id=$ECR_REGISTRY" >> $GITHUB_OUTPUT
      
      - name: Build and push
        id: meta-frontend
        uses: docker/metadata-action@v5
        with:
          images: ${{ steps.ecr-registry.outputs.registry_id }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ secrets.ECR_FRONTEND_REPO }}
          tags: |
            type=sha
            type=raw,value=latest,enable={{is_default_branch}}
            type=ref,event=branch
      
      - uses: docker/build-push-action@v5
        with:
          context: ./frontend
          push: true
          tags: ${{ steps.meta-frontend.outputs.tags }}
          labels: |
            org.opencontainers.image.source=${{ github.repository }}
            org.opencontainers.image.revision=${{ github.event_name == 'workflow_run' && github.event.workflow_run.head_sha || github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
      
      - name: Set image output
        id: image-info
        run: |
          # Get all tags from metadata action
          ALL_TAGS="${{ steps.meta-frontend.outputs.tags }}"
          
          # Prefer SHA tag (unique per commit), fallback to first tag
          IMAGE_TAG=$(echo "$ALL_TAGS" | grep -E "sha-[a-f0-9]+" | head -n1 | sed 's/.*://' || echo "")
          
          if [ -z "$IMAGE_TAG" ]; then
            # Fallback: use first tag or commit SHA
            IMAGE_TAG=$(echo "$ALL_TAGS" | head -n1 | sed 's/.*://' || echo "")
          fi
          
          if [ -z "$IMAGE_TAG" ]; then
            # Last resort: use commit SHA directly
            IMAGE_TAG="${{ github.sha }}"
          fi
          
          # Construct full image path
          ECR_REGISTRY=$(aws sts get-caller-identity --query Account --output text)
          IMAGE="${ECR_REGISTRY}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ secrets.ECR_FRONTEND_REPO }}:${IMAGE_TAG}"
          
          echo "image=$IMAGE" >> $GITHUB_OUTPUT
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "‚úÖ Frontend image: $IMAGE (tag: $IMAGE_TAG)"
          echo "   All available tags: $ALL_TAGS"

  update-gitops-manifest:
    name: Update GitOps Manifest
    needs: [check-ci-status, build-backend, build-frontend]
    if: needs.check-ci-status.outputs.should_deploy == 'true' && needs.build-backend.result == 'success' && needs.build-frontend.result == 'success'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      id-token: write
    steps:
      - name: Checkout Gitops-pipeline
        uses: actions/checkout@v4
        with:
          repository: SaaSInfraLab/Gitops-pipeline
          token: ${{ secrets.GITOPS_REPO_TOKEN }}
          path: gitops-repo
          ref: testing
      
      - name: Install yq
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq
          yq --version
          echo "‚úÖ yq installed successfully"
          
          # Test yq with a sample file
          TEST_FILE="apps/sample-saas-app/base/kustomization.yaml"
          if [ -f "$TEST_FILE" ]; then
            echo "üß™ Testing yq with $TEST_FILE:"
            yq eval '.images[0].newName' "$TEST_FILE" || echo "  ‚ö†Ô∏è  yq test failed"
          fi
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Update image tags and ECR paths in Kustomization files
        working-directory: gitops-repo
        env:
          AWS_REGION: ${{ env.AWS_REGION }}
          ECR_BACKEND_REPO: ${{ secrets.ECR_BACKEND_REPO }}
          ECR_FRONTEND_REPO: ${{ secrets.ECR_FRONTEND_REPO }}
        run: |
          set -e
          
          BACKEND_IMAGE="${{ needs.build-backend.outputs.image }}"
          FRONTEND_IMAGE="${{ needs.build-frontend.outputs.image }}"
          BACKEND_TAG="${{ needs.build-backend.outputs.image_tag }}"
          FRONTEND_TAG="${{ needs.build-frontend.outputs.image_tag }}"
          
          echo "üì¶ Updating GitOps manifests with new image tags and ECR paths..."
          echo "  Backend: $BACKEND_IMAGE (tag: $BACKEND_TAG)"
          echo "  Frontend: $FRONTEND_IMAGE (tag: $FRONTEND_TAG)"
          
          # Get AWS account ID for ECR registry
          ECR_REGISTRY=$(aws sts get-caller-identity --query Account --output text)
          echo "üîç AWS Account ID: $ECR_REGISTRY"
          
          # Use ECR repository names from GitHub secrets
          BACKEND_REPO_NAME="${ECR_BACKEND_REPO}"
          FRONTEND_REPO_NAME="${ECR_FRONTEND_REPO}"
          
          # Construct full ECR image paths
          BACKEND_NAME="${ECR_REGISTRY}.dkr.ecr.${AWS_REGION}.amazonaws.com/${BACKEND_REPO_NAME}"
          FRONTEND_NAME="${ECR_REGISTRY}.dkr.ecr.${AWS_REGION}.amazonaws.com/${FRONTEND_REPO_NAME}"
          
          echo ""
          echo "üìã Final image configuration:"
          echo "  Backend: $BACKEND_NAME:$BACKEND_TAG"
          echo "  Frontend: $FRONTEND_NAME:$FRONTEND_TAG"
          echo ""
          
          # Show current state of files before update
          echo "üîç Current state of kustomization files (before update):"
          for file in apps/sample-saas-app/base/kustomization.yaml \
                      apps/sample-saas-app/overlays/platform/kustomization.yaml \
                      apps/sample-saas-app/overlays/analytics/kustomization.yaml; do
            if [ -f "$file" ]; then
              echo "  $file:"
              echo "    Backend: $(yq eval '.images[0].newName // "NOT_SET"' "$file" 2>/dev/null || echo "ERROR")"
              echo "    Frontend: $(yq eval '.images[1].newName // "NOT_SET"' "$file" 2>/dev/null || echo "ERROR")"
            else
              echo "  $file: NOT FOUND"
            fi
          done
          echo ""
          
          # Function to update kustomization file
          update_kustomization() {
            local kustom_file=$1
            local backend_name=$2
            local frontend_name=$3
            local backend_tag=$4
            local frontend_tag=$5
            
            if [ ! -f "$kustom_file" ]; then
              echo "‚ö†Ô∏è  File not found: $kustom_file"
              return 1
            fi
            
            echo "üìù Updating $kustom_file..."
            
            # Check current values
            CURRENT_BACKEND=$(yq eval '.images[0].newName // "PLACEHOLDER_ECR_BACKEND_URL"' "$kustom_file" 2>/dev/null || echo "PLACEHOLDER_ECR_BACKEND_URL")
            CURRENT_FRONTEND=$(yq eval '.images[1].newName // "PLACEHOLDER_ECR_FRONTEND_URL"' "$kustom_file" 2>/dev/null || echo "PLACEHOLDER_ECR_FRONTEND_URL")
            CURRENT_BACKEND_TAG=$(yq eval '.images[0].newTag // "latest"' "$kustom_file" 2>/dev/null || echo "latest")
            CURRENT_FRONTEND_TAG=$(yq eval '.images[1].newTag // "latest"' "$kustom_file" 2>/dev/null || echo "latest")
            
            echo "  Current Backend: $CURRENT_BACKEND:$CURRENT_BACKEND_TAG"
            echo "  Current Frontend: $CURRENT_FRONTEND:$CURRENT_FRONTEND_TAG"
            echo "  New Backend: $backend_name:$backend_tag"
            echo "  New Frontend: $frontend_name:$frontend_tag"
            
            # Check if update is needed
            # Always update if placeholders are present (first-time deployment)
            if [[ "$CURRENT_BACKEND" == *"PLACEHOLDER"* ]] || [[ "$CURRENT_FRONTEND" == *"PLACEHOLDER"* ]]; then
              echo "  üîÑ Placeholders detected, updating..."
            # Always update if tags match but we have a new build (force ArgoCD sync)
            # This ensures ArgoCD pulls the latest image even if tag is the same
            elif [ "$CURRENT_BACKEND" == "$backend_name" ] && [ "$CURRENT_FRONTEND" == "$frontend_name" ] && \
                 [ "$CURRENT_BACKEND_TAG" == "$backend_tag" ] && [ "$CURRENT_FRONTEND_TAG" == "$frontend_tag" ]; then
              echo "  ‚ÑπÔ∏è  Values match, but updating anyway to trigger ArgoCD sync"
              echo "  üìù Note: This ensures ArgoCD pulls the latest image from ECR"
            else
              echo "  üîÑ Values differ, updating..."
            fi
            
            # Update repository names and tags
            yq eval ".images[0].newName = \"$backend_name\"" -i "$kustom_file" || {
              echo "  ‚ùå Failed to update backend image name"
              return 1
            }
            yq eval ".images[0].newTag = \"$backend_tag\"" -i "$kustom_file" || {
              echo "  ‚ùå Failed to update backend image tag"
              return 1
            }
            yq eval ".images[1].newName = \"$frontend_name\"" -i "$kustom_file" || {
              echo "  ‚ùå Failed to update frontend image name"
              return 1
            }
            yq eval ".images[1].newTag = \"$frontend_tag\"" -i "$kustom_file" || {
              echo "  ‚ùå Failed to update frontend image tag"
              return 1
            }
            
            # Add a timestamp comment to force git to detect a change
            # This ensures ArgoCD syncs even if image tag is the same
            TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
            if ! grep -q "# Updated:" "$kustom_file"; then
              # Add comment at the top if it doesn't exist
              sed -i "1i# Updated: $TIMESTAMP" "$kustom_file"
            else
              # Update existing comment
              sed -i "s/# Updated:.*/# Updated: $TIMESTAMP/" "$kustom_file"
            fi
            
            echo "‚úÖ Updated $kustom_file (timestamp: $TIMESTAMP)"
            return 0
          }
          
          # Track if any files were updated
          FILES_UPDATED=0
          
          # Update base kustomization.yaml
          if update_kustomization "apps/sample-saas-app/base/kustomization.yaml" "$BACKEND_NAME" "$FRONTEND_NAME" "$BACKEND_TAG" "$FRONTEND_TAG"; then
            FILES_UPDATED=$((FILES_UPDATED + 1))
          fi
          
          # Update platform overlay
          if update_kustomization "apps/sample-saas-app/overlays/platform/kustomization.yaml" "$BACKEND_NAME" "$FRONTEND_NAME" "$BACKEND_TAG" "$FRONTEND_TAG"; then
            FILES_UPDATED=$((FILES_UPDATED + 1))
          fi
          
          # Update analytics overlay
          if update_kustomization "apps/sample-saas-app/overlays/analytics/kustomization.yaml" "$BACKEND_NAME" "$FRONTEND_NAME" "$BACKEND_TAG" "$FRONTEND_TAG"; then
            FILES_UPDATED=$((FILES_UPDATED + 1))
          fi
          
          echo ""
          echo "‚úÖ Processed all kustomization files (updated: $FILES_UPDATED)"
          
          # Show what changed
          echo ""
          echo "üìã Git status after updates:"
          git status --short || true
          
          echo ""
          echo "üìã Detailed changes:"
          git diff apps/sample-saas-app/ || echo "No diff output"
          
          # Verify the updates were actually made
          echo ""
          echo "üîç Verifying updates in files:"
          for file in apps/sample-saas-app/base/kustomization.yaml \
                      apps/sample-saas-app/overlays/platform/kustomization.yaml \
                      apps/sample-saas-app/overlays/analytics/kustomization.yaml; do
            if [ -f "$file" ]; then
              echo "  $file:"
              yq eval '.images[0].newName' "$file" 2>/dev/null | head -1 || echo "    (could not read)"
              yq eval '.images[1].newName' "$file" 2>/dev/null | head -1 || echo "    (could not read)"
            fi
          done
      
      - name: Commit and push to GitOps repo
        working-directory: gitops-repo
        run: |
          set -e
          
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Show current status
          echo "üìä Git status before commit:"
          git status --short || true
          
          # Show detailed diff
          echo ""
          echo "üìã Detailed changes:"
          git diff apps/sample-saas-app/ || echo "No diff output"
          
          # Stage all changes in sample-saas-app directory
          git add apps/sample-saas-app/ || {
            echo "‚ö†Ô∏è  No files to stage in apps/sample-saas-app/"
          }
          
          # Check if there are staged changes
          if git diff --staged --quiet; then
            echo ""
            echo "‚ÑπÔ∏è  No changes to commit (images may already be up to date)"
            echo "   This can happen if:"
            echo "   - Images are already at the same tag"
            echo "   - ECR paths are already correct"
            echo "   - Files were already updated in a previous run"
            exit 0
          fi
          
          # Show what will be committed
          echo ""
          echo "üìã Changes to be committed:"
          git diff --staged --stat
          
          # Commit changes
          COMMIT_MSG="chore: update sample-saas-app images to ${{ needs.build-backend.outputs.image_tag }}"
          git commit -m "$COMMIT_MSG" || {
            echo "‚ö†Ô∏è  Commit failed (may already be up to date)"
            exit 0
          }
          
          # Push to testing branch (Argo CD is configured to watch testing)
          TARGET_BRANCH="testing"
          echo ""
          echo "üì§ Pushing to GitOps repo branch: $TARGET_BRANCH"
          git push origin "$TARGET_BRANCH" || {
            echo "‚ùå Failed to push to GitOps repo"
            exit 1
          }
          
          echo ""
          echo "‚úÖ Successfully updated GitOps repository"
          echo "   Commit: $COMMIT_MSG"
          echo "   ArgoCD will automatically detect and deploy the changes"
